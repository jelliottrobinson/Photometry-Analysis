"""
Created on Wed Nov  3 09:49:04 2021

@author: FISXV1
"""
#%% TO DO 
'''
 
Add ability to handle multi channel recordings

'''


#%% import statments

import numpy as np
import math
from exp_dict import EXP_DICT, ORDERED_EXP_DICT
from process_params import (TRANGE, SIGNAL, ISOS, EPOC)
from auto_populate import one_time_inputs

#%% one_time_inputs function for testing, run cell by cell 

#ttl_key_type, exp_input = one_time_inputs()

#%% create custom TDT objects that only contain the necessary information for
# their intended use

class MyTDT:
    '''
      This class is the main product of the preprocessing step in our data 
    analysis pipeline and replaces the TDT data structure. 
    '''
    def __init__(self, tdtObj, ttl_key_type = None, exp_input = None):
        # extract only the necessary components of the TDT object
        self.epoch_trange = TRANGE
        self.isos = tdtObj.streams[ISOS].data
        self.sig = tdtObj.streams[SIGNAL].data
        self.fs = tdtObj.streams[ISOS].fs
        self.info = tdtObj.info

        # determine channel of the photometry data - ADD FEATURE TO HANDLE DUAL CHANNEL RECORDINGS. TEST IN CURRENT STATE FIRST
        self.channel = EPOC
        self.epoch_onset = tdtObj.epocs[self.channel].onset#[np.where(tdtObj\
                           #.epocs[self.channel].data==33)]
# =============================================================================
#         temp = []    
#         for x in range(len(self.epoch_onset)):
#             if x%3 == 0:
#                 temp.append(self.epoch_onset[x])
# =============================================================================
                
        self.epoch_offset = tdtObj.epocs[self.channel].offset#[np.where(tdtObj\
                           #.epocs[self.channel].data==33)]
# =============================================================================
#         temp = []    
#         for x in range(len(self.epoch_offset)):
#             if x%3 == 0:
#                 temp.append(self.epoch_offset[x])
# =============================================================================

        # attributes added to MyTDT - generated from data in tdtObj
        self.time = np.linspace(0, len(self.isos)/self.fs, len(self.isos))
        self.total_epochs = len(self.epoch_onset)
        
        # attributes generated by MyTDT class methods
        # these make up the bulk of the pre-processing 
        self.ttl_key_type = None
        if ttl_key_type == None:
            self.find_ttl_key_type()
        else:
            self.ttl_key_type = ttl_key_type

        # call all methods to construct the remaining attributes
        self.find_stim_keys()
        self.exp_identifier(exp_input)
        self.find_epoch_inds()
        self.gen_epoch_snips(TRANGE)
        self.find_epoch_dict()
        
# =============================================================================
#     def __repr__(self):
#         return 'Object: MyTDT Object'
# =============================================================================
    
    def __repr__(self):
        blockname = self.info.blockname
        name = blockname.split('_')[0]
        return str(name)

    def find_ttl_key_type(self):
        '''
            This method determines how the different experimental stimuli
        are labeled
        '''
        while self.ttl_key_type == None:       
            user_input = input('Choose the stimulus identifying method: \n'
                               '1: single stimulus\n'
                               '2: ttl pulsewidth\n'
                               '3: presentation order\n\n')
            if user_input == '1':
                ttl_key_type = 'single stimulus'
            elif user_input == '2':
                ttl_key_type = 'ttl pulse width'
            elif user_input == '3':
                ttl_key_type = 'presentation order'
            else:
                print('Input not recognized.')
            self.ttl_key_type = ttl_key_type

    # produces a stim_keys attribute - list of all ttl lengths in order
    def find_stim_keys(self):
        '''
          This method produces a stim_keys attribute: list of all ttl pulse 
        widths in order of their presentation during the experimental session
        
          The set of pulse widths is unique to each type of experiment.
        These pulse widths are termed "stim keys" as they will serve as the 
        keys for accessing the corresponding stimulus in the experiment 
        dictionaries.
        '''
        ttls = []
        for ind in range(self.total_epochs):
            ttl = self.epoch_offset[ind] - self.epoch_onset[ind]
            ttl = round(ttl, 3)
            ttls.append(ttl)
        self.stim_keys = ttls 
    
    def exp_identifier(self, exp_input):
        '''
            This method determines the experimental conditions for the provided
        data file. This is determined by the ttl pulse widths of from user
        input in the case that the presentation order determines the presented
        stimulus.
        '''
        pulse_width = set(self.stim_keys)
        if self.ttl_key_type == 'ttl pulse width':
            for exp in EXP_DICT.items():
                if pulse_width == set(exp[1].keys()):
                    self.exp_dict = exp
                    self.experiment = exp[0]
        elif self.ttl_key_type == 'presentation order':
            choice = 1
            choices = []
            if exp_input == None:    
                print('Choose the type of experiment: \n')
                for exp in ORDERED_EXP_DICT.items():
                    print(f'{choice}: {exp[0]}\n')
                    print(f'{exp[1].keys()}\n')
                    choice += 1
                    choices.append(choice)
                exp_input = int(input())
            if exp_input-1 in range(len(ORDERED_EXP_DICT.values())):
                self.exp_dict = (list(ORDERED_EXP_DICT.values())
                                [exp_input-1])
                self.experiment = (list(ORDERED_EXP_DICT.items())
                                [exp_input-1][0])
            else:
                print('Input not recognized. Rerun the script with an '
                      'appropriate input.')
        elif self.ttl_key_type == 'single stimulus':
            if exp_input == None:
                self.experiment = input('What is the experiment '
                                        'stimulus/condition?\n\n')                
            else:
                self.experiment = exp_input
            self.exp_dict = dict(zip([1], [self.experiment]))
        else: 
            print('ttl_key_type not recognized - '
                  'this is most likely an issue with the program.')
                               
    # produces a list of indices of ttl onsets 
    # these indices map onto time, isos and sig attributes
    def find_epoch_inds(self):
        '''
            This method produces a list of indices of ttl onset. These indices
        map onto the time, isos, and sig data streams

        '''    
        inds = []
        for i in range(self.total_epochs):
            arr = self.time
            val = self.epoch_onset[i]
            try:
                ind = np.searchsorted(arr, val, side="left")            
                if math.fabs(val - arr[ind]) > math.fabs(val - arr[ind-1]):  
                    ind-=1
                inds.append(ind)
            except: 
                ind = np.searchsorted(arr, val, side="left")-1            
                if math.fabs(val - arr[ind]) > math.fabs(val - arr[ind-1]):  
                    ind-=1
                inds.append(ind)
        self.epoch_inds = inds
        
    # produces a list of epoch filtered stream in TRANGE where TRANGE[0] is a 
    # number of seconds before epoch onset and TRANGE[1] is the total time (s)
    # of the epoch stream
    def gen_epoch_snips(self, TRANGE):
        '''
        Parameters
        ----------
        TRANGE : List of 2 values
            TRANGE[0] : number of seconds before epoch onset to filter from
            TRANGE[1] : number of total seconds of the epoch stream
            Only edit this variable from the process_params.py file in the
            same directory as this file
        ----------
        
        Produces a list of epoch filtered streams based on the TRANGE parameter
        as the isos_filtered and sig_filtered attributes

        '''
        self.isos_filtered = []
        self.sig_filtered = []
        for i in self.epoch_inds:
            start = i + int(TRANGE[0]*self.fs)
            stop = start + int(TRANGE[1]*self.fs)
            isos = self.isos[start: stop]
            sig = self.sig[start: stop]
            self.isos_filtered.append(isos)
            self.sig_filtered.append(sig)

# this may be redundant when exp_dict exists, remove if unused
# only useful in ttl pulse width condition id
    def find_epoch_dict(self):
        '''
            This method zips the stim keys and epoch snips into a list
        for easy identification of the presented stimulus for a given epoch
        '''
        try:
            self.epoch_dict = list(zip(self.stim_keys, self.sig_filtered, self.isos_filtered))
        except:
            print('epoch_dict left as None Type')
        
    


